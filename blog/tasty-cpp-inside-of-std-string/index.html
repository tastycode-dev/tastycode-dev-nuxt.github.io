<!DOCTYPE html>
<html >
<head><meta charset="utf-8">
<title>Tasty C++ – Memory Layout of std::string</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="Tasty C++ – Memory Layout of std::string">
<meta name="description" content="For a professional C++ developer, it's crucial to understand memory organization of the data
structures and complexity of their operations. This is especially important when working with the
C++ Standard Library. In this post of Tasty C++ series we'll look under the hood of std::string,
so that you can work with C++ strings more effectively when designing your code and data structures.">
<meta property="og:description" content="For a professional C++ developer, it's crucial to understand memory organization of the data
structures and complexity of their operations. This is especially important when working with the
C++ Standard Library. In this post of Tasty C++ series we'll look under the hood of std::string,
so that you can work with C++ strings more effectively when designing your code and data structures."><link rel="preload" as="fetch" crossorigin="anonymous" href="/blog/tasty-cpp-inside-of-std-string/_payload.json"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/entry.54b719a7.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/_...slug_.2f79d9a3.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/ContentRenderer.7ce12bef.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/ContentRendererMarkdown.90079dee.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/index.a6ef77ff.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/preview.99057698.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/ContentDoc.f0762927.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/ContentQuery.5d2e9650.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/asyncData.f0f2c443.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/query.ca836eec.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/utils.646c694b.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/ProseP.fb7d7bad.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/ProseCodeInline.f71f52a6.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/ProseEm.a7345e8c.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/ProseH2.46eb529c.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/ProseUl.122d154c.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/ProseLi.26d335b7.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/ProseStrong.a8db61f2.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/ProseCode.8ecc850b.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/ProseTable.ee126f58.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/ProseThead.ce796728.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/ProseTr.7e93cefa.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/ProseTh.eff40bd1.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/ProseTbody.7575cbd9.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/ProseTd.7c2c389d.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/ProseOl.ab7b018c.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/ProseA.03293d4a.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/nuxt-link.167c39f5.js"><link rel="modulepreload" as="script" crossorigin href="/_nuxt/ProseImg.705749e1.js"><link rel="prefetch" as="script" crossorigin href="/_nuxt/error-404.39003d06.js"><link rel="prefetch" as="script" crossorigin href="/_nuxt/error-500.29d2d29f.js"><style>pre code .line{display:block;min-height:1rem}</style><style>/*! tailwindcss v3.3.3 | MIT License | https://tailwindcss.com*/*,:after,:before{border:0 solid #e5e7eb;box-sizing:border-box}:after,:before{--tw-content:""}html{-webkit-text-size-adjust:100%;font-feature-settings:normal;font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;font-variation-settings:normal;line-height:1.5;tab-size:4}body{line-height:inherit;margin:0}hr{border-top-width:1px;color:inherit;height:0}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{border-collapse:collapse;border-color:inherit;text-indent:0}button,input,optgroup,select,textarea{font-feature-settings:inherit;color:inherit;font-family:inherit;font-size:100%;font-variation-settings:inherit;font-weight:inherit;line-height:inherit;margin:0;padding:0}button,select{text-transform:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0}fieldset,legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{color:#9ca3af;opacity:1}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{height:auto;max-width:100%}[hidden]{display:none}*,:after,:before{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgba(59,130,246,.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: }.absolute{position:absolute}.relative{position:relative}.table{display:table}.grid{display:grid}.pb-2{padding-bottom:.5rem}.align-middle{vertical-align:middle}</style><style>a{text-decoration-line:none;text-underline-offset:2px}a:hover{text-decoration-line:underline}a{color:blue}address{font-style:normal}article{background-color:#f5f5f5;min-height:100vh;padding-left:3rem;padding-right:3rem}body{background-color:#e5e5e5;color:#262626;font-family:Lato,sans-serif;margin:auto;max-width:86ch;padding-left:2rem;padding-right:2rem}figure{padding-bottom:2rem}h1{--tw-border-opacity:1;border:2px solid #000;border-color:rgb(0 0 0/var(--tw-border-opacity));box-shadow:.5rem .5rem #000;font-size:1.875rem;font-weight:700;letter-spacing:-.025em;line-height:2.25rem;margin-bottom:1.25rem;margin-top:.5rem;padding:.75rem;text-align:center}h2{font-size:1.5rem;line-height:2rem;padding-top:.75rem}h2,h3{padding-bottom:.5rem}h3{font-size:1.25rem;line-height:1.75rem;padding-top:.5rem}header{padding-bottom:1.5rem}html{font-size:18px}li{margin-inline-start:2rem;padding-bottom:.5rem}ol{list-style-position:outside;list-style-type:decimal}ol,p{margin-bottom:1rem}p{line-height:1.625;margin-top:0}pre{--tw-border-opacity:1;--tw-bg-opacity:1;background-color:#fff;background-color:rgb(255 255 255/var(--tw-bg-opacity));border-color:#a3a3a3;border-color:rgb(163 163 163/var(--tw-border-opacity));border-style:solid;border-width:1px;margin-bottom:1rem;padding:.5rem 1rem}table{margin:auto auto 1rem}table td,th,tr{--tw-border-opacity:1;border-color:#d4d4d4;border-color:rgb(212 212 212/var(--tw-border-opacity));border-width:1px;padding:.25rem;text-align:center;vertical-align:top}th{background-color:#e5e5e5;background-color:rgb(229 229 229/var(--tw-bg-opacity))}th,tr{--tw-bg-opacity:1;padding-left:1rem;padding-right:1rem}tr{background-color:#fff;background-color:rgb(255 255 255/var(--tw-bg-opacity))}ul{list-style-position:outside;list-style-type:disc;margin-bottom:1rem}.article-body>p:first-child{--tw-text-opacity:1;color:#292524;color:rgb(41 37 36/var(--tw-text-opacity));font-size:1.125rem;line-height:1.75rem;line-height:1.625;margin-bottom:2rem;margin-top:0}.header{display:block;font-size:1.5rem;font-weight:700;letter-spacing:-.05em;line-height:2rem}.header a{color:inherit;text-decoration:inherit}#logo{display:inline-flex;margin-inline-end:.5rem;padding-bottom:1rem;padding-top:1rem;width:2rem}</style></head>
<body ><div id="__nuxt"><!--[--><article><div class="header"><a id="header" href="/"><img src="/img/logo.png" id="logo"><span class="align-middle">TastyCode</span></a></div><!--[--><header><h1>Tasty C++ – Memory Layout of std::string</h1><address><a href="https://gituliar.net" rel="author">Oleksandr Gituliar</a> • <time>2023-08-07</time></address></header><div class="article-body"><p><!--[-->For a professional C++ developer, it&#39;s crucial to understand memory organization of the data
structures and complexity of their operations. This is especially important when working with the
C++ Standard Library. In this post of Tasty C++ series we&#39;ll look under the hood of <code><!--[-->std::string<!--]--></code>,
so that you can work with C++ strings more effectively when designing your code and data structures.<!--]--></p><p><!--[-->In C++, <code><!--[-->std::string<!--]--></code> is a sequence of characters that are stored in the buffer that spans a
<em><!--[-->contiguous<!--]--></em> memory area. This means that individual characters can be efficiently accessed by index
at O(1) time. The C++ Standard imposes other requirements on the complexity of common operations
with strings. However, it doesn&#39;t specify how exactly <code><!--[-->std::string<!--]--></code> should be implemented.<!--]--></p><p><!--[-->In practice, various implementations of the C++ Standard Library use considerably different
approaches. For example, the result of <code><!--[-->sizeof(std::string)<!--]--></code> depends on what library is used.<!--]--></p><h2 id="long-strings"><a href="#long-strings"><!--[-->Long Strings<!--]--></a></h2><p><!--[-->Usually, to fully represent its internal state, <code><!--[-->std::string<!--]--></code> needs three pieces of information:<!--]--></p><ul><!--[--><li><!--[--><strong><!--[-->Size<!--]--></strong> – the current number of characters in the string.<!--]--></li><li><!--[--><strong><!--[-->Buffer<!--]--></strong> – the pointer to the memory buffer where characters are stored.<!--]--></li><li><!--[--><strong><!--[-->Capacity<!--]--></strong> – the max number of character the buffer can fit.<!--]--></li><!--]--></ul><p><!--[-->In fact, the <em><!--[-->capacity<!--]--></em> is not required. We can use <em><!--[-->size<!--]--></em> and <em><!--[-->buffer<!--]--></em> only, but when the string
grows, a new buffer should be allocated on the heap (because we can&#39;t tell how many extra characters
the current buffer can fit). Since heap allocation is slow, such allocations are avoided by tracking
the buffer capacity.<!--]--></p><p><!--[-->Following this logic, we could implement a C++ string as:<!--]--></p><!--[--><pre><code><span class="line" line="1"><span class="ct-748473">class</span><span class="ct-996399"> </span><span class="ct-970031">MyString</span><span class="ct-996399"> {
</span></span><span class="line" line="2"><span class="ct-996399">    </span><span class="ct-748473">size_t</span><span class="ct-996399">    m_size;
</span></span><span class="line" line="3"><span class="ct-996399">    </span><span class="ct-748473">char</span><span class="ct-996399"> </span><span class="ct-748473">*</span><span class="ct-996399">    m_buffer;
</span></span><span class="line" line="4"><span class="ct-996399">    </span><span class="ct-748473">size_t</span><span class="ct-996399">    m_capacity;
</span></span><span class="line" line="5"><span class="ct-996399">}</span></span></code></pre><!--]--><p><!--[--><code><!--[-->MyString<!--]--></code> occupies 24 bytes, which is only 3x more than <strong><!--[-->fundamental types<!--]--></strong> such as <code><!--[-->void *<!--]--></code>,
<code><!--[-->size_t<!--]--></code>, or <code><!--[-->double<!--]--></code>.<!--]--></p><p><!--[-->Let&#39;s see how things look in reality. In the <em><!--[-->most popular implementations<!--]--></em> of the C++ Standard
Library the size of <code><!--[-->std::string<!--]--></code> object is the following:<!--]--></p><table><!--[--><thead><!--[--><tr><!--[--><th><!--[-->C++ Standard Library<!--]--></th><th><!--[-->Size of std::string()<!--]--></th><!--]--></tr><!--]--></thead><tbody><!--[--><tr><!--[--><td><!--[-->MSVC STL<!--]--></td><td><!--[-->32 bytes<!--]--></td><!--]--></tr><tr><!--[--><td><!--[-->GCC libstdc++<!--]--></td><td><!--[-->32 bytes<!--]--></td><!--]--></tr><tr><!--[--><td><!--[-->LLVM libc++<!--]--></td><td><!--[-->24 bytes<!--]--></td><!--]--></tr><!--]--></tbody><!--]--></table><p><!--[-->To our surprise, only <strong><!--[-->LLVM<!--]--></strong> allocates expected <strong><!--[-->24 bytes<!--]--></strong> for <code><!--[-->std::string<!--]--></code>. The other two,
<strong><!--[-->MSVC<!--]--></strong> and <strong><!--[-->GCC<!--]--></strong>, allocate <strong><!--[-->32 bytes<!--]--></strong> for the same string. (For completeness, note that in the
<em><!--[-->debug mode<!--]--></em> MSVC allocates 40 bytes for <code><!--[-->std::string<!--]--></code>.)<!--]--></p><h2 id="short-strings"><a href="#short-strings"><!--[-->Short Strings<!--]--></a></h2><p><!--[-->Let&#39;s get some intuition about why various implementation allocate different amount of memory for
the same object. In fact, 24 or 32 bytes is already enough to fit a relatively big string, with no
need to allocate dynamic memory (and free it afterwards, which is costly as well). The trick, called
<strong><!--[-->Small String Optimization<!--]--></strong> (aka SSO), is to store string characters in the memory dedicated for
the size, capacity, and data pointer fields. Not sure this technique is part of the C++ Standard,
but for sure it&#39;s popular among various implementations.<!--]--></p><p><!--[-->Without going into much technicalities of SSO, let&#39;s mention two points worth to remember.<!--]--></p><ol><!--[--><li><!--[--><strong><!--[-->How big are short strings?<!--]--></strong> It seems obvious that every implementation is free to extend
internal buffer for a small string far beyond required 24 bytes. This is why <code><!--[-->std::string<!--]--></code> in
MSVC and GCC is 32 bytes. However, the result of <strong><!--[--><code><!--[-->std::string().capacity()<!--]--></code><!--]--></strong> is:<br><br><table><!--[--><thead><!--[--><tr><!--[--><th><!--[-->C++ Standard Library<!--]--></th><th><!--[-->Capacity of std::string()<!--]--></th><!--]--></tr><!--]--></thead><tbody><!--[--><tr><!--[--><td><!--[-->MSVC STL<!--]--></td><td><!--[-->15 chars<!--]--></td><!--]--></tr><tr><!--[--><td><!--[-->GCC libstdc++<!--]--></td><td><!--[-->15 chars<!--]--></td><!--]--></tr><tr><!--[--><td><!--[-->LLVM libc++<!--]--></td><td><!--[-->22 chars<!--]--></td><!--]--></tr><!--]--></tbody><!--]--></table><p><!--[-->Again, LLVM version seems to beat MSVC and GCC, since for a smaller memory usage (24 bytes) it&#39;s
able to store longer strings (22 chars). (In fact, it&#39;s possible to fully utilize the memory and
fit 23 chars + <code><!--[-->&#39;\0&#39;<!--]--></code>.)<!--]--></p><!--]--></li><li><!--[--><strong><!--[-->How fast are short strings?<!--]--></strong> In this particular case, utilizing more space is not for
free. The more characters we pack into a string&#39;s memory area, the more CPU operations we have to
run. For LLVM, with its superior memory efficiency, even such a simple call as <code><!--[-->size()<!--]--></code> requires
to check if the string is short or long. This sort of conditions might slow down a calculation
pipeline.<br><br><p><!--[-->A simple example of <code><!--[-->size()<!--]--></code> method clearly demonstrates this point. (BTW, this is one of
the most commonly used method of <code><!--[-->std::string<!--]--></code>.)<!--]--></p><p><!--[--><strong><!--[-->GCC stdlibc++<!--]--></strong> code (see <a href="https://godbolt.org/z/7nYe9rWdE" rel="nofollow"><!--[-->https://godbolt.org/z/7nYe9rWdE<!--]--></a>) directly copies string&#39;s size into
the output register:<!--]--></p><table><!--[--><thead><!--[--><tr><!--[--><th><!--[-->Example<!--]--></th><th><!--[-->GCC libstdc++<!--]--></th><!--]--></tr><!--]--></thead><tbody><!--[--><tr><!--[--><td><!--[--><img src="/img/string-size-src.png" alt><!--]--></td><td><!--[--><img src="/img/string-size-gcc.png" alt><!--]--></td><!--]--></tr><!--]--></tbody><!--]--></table><p><!--[--><strong><!--[-->LLVM libc++<!--]--></strong> code (see <a href="https://godbolt.org/z/xM349cG5P" rel="nofollow"><!--[-->https://godbolt.org/z/xM349cG5P<!--]--></a>) at first checks if the string is short
and then calculates its size.<!--]--></p><table><!--[--><thead><!--[--><tr><!--[--><th><!--[-->Example<!--]--></th><th><!--[-->LLVM libc++<!--]--></th><!--]--></tr><!--]--></thead><tbody><!--[--><tr><!--[--><td><!--[--><img src="/img/string-size-src.png" alt><!--]--></td><td><!--[--><img src="/img/string-size-llvm.png" alt><!--]--></td><!--]--></tr><!--]--></tbody><!--]--></table><!--]--></li><!--]--></ol><p><!--[-->Eventually, it&#39;s hard to say which approach is more efficient. Now, that you know the difference,
the best advice here is to experiment with various implementations and benchmark your particular use
case.<!--]--></p><h2 id="memory-allocation-policy"><a href="#memory-allocation-policy"><!--[-->Memory Allocation Policy<!--]--></a></h2><p><!--[-->Finally, let&#39;s see how <code><!--[-->std::string<!--]--></code> grows its internal buffer when it&#39;s time to allocate more
memory. Some <a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/basic_string.tcc#L142" rel="nofollow"><!--[-->comments in the GCC
sources<!--]--></a>,
mentioned <em><!--[-->amortized linear time requirement<!--]--></em> and <em><!--[-->exponential growth policy<!--]--></em>. Not clear if this is
internal GCC decision or part of the C++ Standard. In any case, all three implementations use
exponential growth, so that <strong><!--[-->MSVC<!--]--></strong> has <strong><!--[-->1.5x factor<!--]--></strong> growth, while <strong><!--[-->GCC<!--]--></strong> and <strong><!--[-->LLVM<!--]--></strong> use <strong><!--[-->2x
factor<!--]--></strong>. Below are some examples with more explicit (but simplified) code:<!--]--></p><p><!--[--><strong><!--[-->MSVC STL<!--]--></strong><!--]--></p><!--[--><pre><code><span class="line" line="1"><span class="ct-748473">size_t</span><span class="ct-996399"> </span><span class="ct-970031">newCapacity</span><span class="ct-996399">(</span><span class="ct-748473">size_t</span><span class="ct-996399"> </span><span class="ct-441542">newSize</span><span class="ct-996399">, </span><span class="ct-748473">size_t</span><span class="ct-996399"> </span><span class="ct-441542">oldCap</span><span class="ct-996399">) {
</span></span><span class="line" line="2"><span class="ct-996399">    </span><span class="ct-748473">return</span><span class="ct-996399"> </span><span class="ct-970031">max</span><span class="ct-996399">(newSize, oldCap </span><span class="ct-748473">+</span><span class="ct-996399"> oldCap </span><span class="ct-748473">/</span><span class="ct-996399"> </span><span class="ct-531245">2</span><span class="ct-996399">);
</span></span><span class="line" line="3"><span class="ct-996399">}</span></span></code></pre><!--]--><p><!--[-->Example: 15, 31, 47, 70, 105, 157, 235, 352, 528, 792, 1&#39;188, 1&#39;782, 2&#39;673, 4&#39;009.<!--]--></p><p><!--[--><strong><!--[-->GCC libstdc++<!--]--></strong><!--]--></p><!--[--><pre><code><span class="line" line="1"><span class="ct-748473">size_t</span><span class="ct-996399"> </span><span class="ct-970031">newCapacity</span><span class="ct-996399">(</span><span class="ct-748473">size_t</span><span class="ct-996399"> </span><span class="ct-441542">newSize</span><span class="ct-996399">, </span><span class="ct-748473">size_t</span><span class="ct-996399"> </span><span class="ct-441542">oldCap</span><span class="ct-996399">) {
</span></span><span class="line" line="2"><span class="ct-996399">    </span><span class="ct-748473">return</span><span class="ct-996399"> </span><span class="ct-970031">max</span><span class="ct-996399">(newSize </span><span class="ct-748473">+</span><span class="ct-996399"> </span><span class="ct-531245">1</span><span class="ct-996399">, </span><span class="ct-531245">2</span><span class="ct-996399"> </span><span class="ct-748473">*</span><span class="ct-996399"> oldCap);
</span></span><span class="line" line="3"><span class="ct-996399">}</span></span></code></pre><!--]--><p><!--[-->Example: 15, 30, 60, 120, 240, 480, 960, 1&#39;920, 3&#39;840, 7&#39;680, 15&#39;360, 30&#39;720.<!--]--></p><p><!--[--><strong><!--[-->LLVM libc++<!--]--></strong><!--]--></p><!--[--><pre><code><span class="line" line="1"><span class="ct-748473">size_t</span><span class="ct-996399"> </span><span class="ct-970031">newCapacity</span><span class="ct-996399">(</span><span class="ct-748473">size_t</span><span class="ct-996399"> </span><span class="ct-441542">newSize</span><span class="ct-996399">, </span><span class="ct-748473">size_t</span><span class="ct-996399"> </span><span class="ct-441542">oldCap</span><span class="ct-996399">) {
</span></span><span class="line" line="2"><span class="ct-996399">    </span><span class="ct-748473">return</span><span class="ct-996399"> </span><span class="ct-970031">max</span><span class="ct-996399">(newSize, </span><span class="ct-531245">2</span><span class="ct-996399"> </span><span class="ct-748473">*</span><span class="ct-996399"> oldCap) </span><span class="ct-748473">+</span><span class="ct-996399"> </span><span class="ct-531245">1</span><span class="ct-996399">;
</span></span><span class="line" line="3"><span class="ct-996399">}</span></span></code></pre><!--]--><p><!--[-->Example: 22, 47, 95, 191, 383, 767, 1&#39;535, 3&#39;071, 6&#39;143, 12&#39;287, 24&#39;575, 49&#39;151.<!--]--></p><h2 id="summary"><a href="#summary"><!--[-->Summary<!--]--></a></h2><p><!--[-->Because the C++ Standard doesn&#39;t provide specific implementation details for <code><!--[-->std::string<!--]--></code>, there
are a couple of tradeoffs for the developer of the C++ Standard Library to consider:<!--]--></p><ul><!--[--><li><!--[--><strong><!--[-->Size<!--]--></strong>: <em><!--[-->24 bytes<!--]--></em> (LLVM) vs <em><!--[-->32 bytes<!--]--></em> (GCC, MSVC)<!--]--></li><li><!--[--><strong><!--[-->Capacity<!--]--></strong>: <em><!--[-->15 chars + Simple Code<!--]--></em> (GCC, MSVC) vs <em><!--[-->22 chars + Complex Code<!--]--></em> (LLVM)<!--]--></li><li><!--[--><strong><!--[-->Growth Policy<!--]--></strong>: Exponential with <em><!--[-->1.5x factor<!--]--></em> (MSVC) vs <em><!--[-->2x factor<!--]--></em> (GCC, LLVM)<!--]--></li><!--]--></ul><p><!--[-->In some cases they might be the nice features provided directly by the C++ Standard Library. In
other situations they might be the limitations, which require extra attention from your side or even
completely new implementation.<!--]--></p><p><!--[-->Hopefully, these details will make you a better programmer, help write more efficient C++ code, and
design better data structures.<!--]--></p><p><!--[--><strong><!--[-->Recommended Links:<!--]--></strong><!--]--></p><ul><!--[--><li><!--[-->&quot;libc++&#39;s implementation of std::string&quot; by Joel Laity:<br><a href="https://joellaity.com/2020/01/31/string.html" rel="nofollow"><!--[-->https://joellaity.com/2020/01/31/string.html<!--]--></a><br>Discussion on Hacker News:<br><a href="https://news.ycombinator.com/item?id=22198158" rel="nofollow"><!--[-->https://news.ycombinator.com/item?id=22198158<!--]--></a><!--]--></li><li><!--[-->CppCon 2016: “The strange details of std::string at Facebook&quot; by Nicholas Ormrod:<br><a href="https://www.youtube.com/watch?v=kPR8h4-qZdk" rel="nofollow"><!--[-->https://www.youtube.com/watch?v=kPR8h4-qZdk<!--]--></a><!--]--></li><!--]--></ul><p><!--[-->TastyCode by Oleksandr Gituliar.<!--]--></p><style>.ct-748473{color:#D73A49;}
.ct-996399{color:#24292E;}
.ct-970031{color:#6F42C1;}
.ct-441542{color:#E36209;}
.ct-531245{color:#005CC5;}</style></div><!--]--></article><!--]--></div><script type="application/json" id="__NUXT_DATA__" data-ssr="true" data-src="/blog/tasty-cpp-inside-of-std-string/_payload.json">[{"state":1,"_errors":3,"serverRendered":6,"path":7,"prerenderedAt":8},["Reactive",2],{},["Reactive",4],{"content-query-H8prIUMV1J":5},null,true,"/blog/tasty-cpp-inside-of-std-string",1691443215385]</script><script>window.__NUXT__={};window.__NUXT__.config={public:{content:{locales:[],defaultLocale:"",integrity:1691443203955,experimental:{stripQueryParameters:false,clientDB:false},respectPathCase:false,api:{baseURL:"/api/_content"},navigation:{fields:[]},tags:{p:"prose-p",a:"prose-a",blockquote:"prose-blockquote","code-inline":"prose-code-inline",code:"prose-code",em:"prose-em",h1:"prose-h1",h2:"prose-h2",h3:"prose-h3",h4:"prose-h4",h5:"prose-h5",h6:"prose-h6",hr:"prose-hr",img:"prose-img",ul:"prose-ul",ol:"prose-ol",li:"prose-li",strong:"prose-strong",table:"prose-table",thead:"prose-thead",tbody:"prose-tbody",td:"prose-td",th:"prose-th",tr:"prose-tr"},highlight:{theme:"github-light",preload:["cpp"]},wsUrl:"",documentDriven:false,host:"",trailingSlash:false,anchorLinks:{depth:4,exclude:[1]}}},app:{baseURL:"/",buildAssetsDir:"/_nuxt/",cdnURL:""}}</script><script type="module" src="/_nuxt/entry.54b719a7.js" crossorigin></script></body>
</html>